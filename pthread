    相对于 Unix 操作系统 40 多年的光辉历史，线程算是出现的比较晚的。在 20 世纪 90 年代线程才慢慢流行起来，而 POSIX threads 标准的确立已经是 1995 年的
事情了。
    Unix 原本是不支持线程的，线程概念的引入给 Unix 家族带来了一些麻烦，很多函数都不是线程安全的，需要重新定义，信号机制在线程加入以后也变得更加复杂了。
    在单核 CPU 时代，多线程的需求并没有那么强烈，但是随着时间流逝，处理器厂商改善 CPU 性能的传统方法，如提升时钟速度和指令吞吐量，基本已经走到了尽头，
处理器开始向超线程和多核架构靠拢，多核的时代已经来临。为了让代码运行的更快，单纯的依赖更快的硬件已经无法满足要求。程序员需要编写并发代码，以便充分发挥
多核处理器的强大功能，并且使程序的性能得到提高。

一.线程与进程
    在 Linux 下，程序或可执行文件是一个静态的实体，它只是一组指令的集合，没有执行的含义。进程是一个动态的实体，有自己的生命周期。线程是操作系统进程调度器
 可以调度的最小执行单元。进程和线程的关系：
	1.单线程进程
	2.多线程进程
	3.多个单线程进程
	4.多个多线程进程
    一个进程可能包含多个线程，传统意义上的进程，不过是多线程的一个特例，即该进程只包含一个线程。

    Unix/Linux 原本的设计是没有线程的，Unix 系统包括 Linux 从设计上更倾向于使用进程，反倒是 Windows 因为创建进程的开销巨大，而更加钟爱线程。
    进程之间，彼此的地址空间是独立的，但是线程会共享内存地址空间，同一个进程的多个线程共享一份全局内存区域，包括初始化数据段、未初始化数据段和动态分配的
堆内存段。这种共享给线程带来了很多优势：
	1.创建线程花费的时间要小于创建进程花费的时间（创建进程需要拷贝页表）
	2.终止线程花费的时间要小于终止进程花费的时间
	3.线程之间上下文切换的开销要小于进程之间的上下文开销
	4.线程之间数据的共享比进程之间的共享要简单
	5.线程之间通信的代价低于进程之间通信的代价
    线程间的上下文切换，指的是同一个进程里不同线程之间发生的上下文切换。由于线程原本属于同一个进程，他们会共享地址空间，大量资源共享，切换的代价小于进程
之间切换的代价是自然而然的事情。

    CPU 是一种资源，如果一方面 CPU 资源大量闲置，处于 IDLE 状态，另一方面很多任务得不到及时的处理，处于排队等待状态，这就表明资源没有得到有效利用，本质上
是一种浪费。
    如果存在多个相同的任务，彼此之间并行不悖，互不依赖（或者依赖性很小），那么启动多个线程并发处理，是一个不错的选择。虽然对每个任务而言，处理的时间并
没有缩短，但是在相同时间内，处理了更多的任务。
    有很多程序天生就适合用多线程。将工作切分成多个模块，并为每个模块分配一个或多个执行单元，更符合人类解决问题的思路。
    以文本编辑程序为例，用户的输入需要及时响应，必须要有线程来监控鼠标和键盘；如果用户删除了某一行，后面很多页的格式都会收到影响，这时就需要有文本格式化
程序在后台执行格式处理；很多文本编辑软件都有自动保存的功能，第三个线程会周期性地将文件内容写入磁盘；很多文本编辑软件都有检测拼写错误的功能，或许我们需要
第四个线程...

    目前存在的并发编程，基本可以分为两类：
	1.共享状态时
	2.消息传递式
    线程模型采用的是第一种。
    
    多线程带来优势的同时，也存在一些弊端：
	1.多线程的进程，因地址空间的共享让该进程变得更加脆弱
 	    多个线程之中，只要有一个线程不够健壮存在 bug，就会导致进程内的所有线程一起完蛋
  	    相比之下，进程的地址空间相互独立，彼此隔离的更加彻底。多个进程之间互相协同，一个进程存在 bug 导致异常退出，不会影响其它进程
	2.线程模型作为一种并发的编程模型，效率并没有想象的那么高，会出现复杂度高、易出错、难以测试和定位的问题
	    首先，多个线程之间，存在负载均衡的问题，现实中很难将全部任务等分给每个线程
	    其次，多个线程的任务之间还可能存在顺序依赖的关系，一个线程未完成某些操作之前，其它线程不能或不应该运行

    多个线程之间需要同步。多个线程生活在进程地址空间这个屋檐下，若存在多个线程操作共享资源，则需要同步，否则可能会出现结果错误、数据结构遭到破坏甚至是
程序崩溃等后果。因此多线程编程中存在临界区的概念，临界区的代码只允许一个线程执行，线程提供了锁机制来保护临界区。当其他线程来到临界区却无法申请到锁时，
就可能陷入阻塞，不再处于可执行状态，线程可能不得不让出 CPU 资源。如果设计不合理，临界区非常多，线程之间的竞争异常激烈，频繁的上下文切换也会导致性能急剧
恶化。
    多线程模型的复杂度更是不容小瞧。很多人诟病多线程模型，就在于它不符合人的心智模型。人很难同时控制多条走走停停，彼此又有交互和同步的执行流。由于进程
调度的无序性，严格来说多线程程序的每次执行其实并不一样，很难穷举所有的时许组合，所以我们永远无法宣称多线程的程序经过了充分的测试。在某些特殊时许的条件下
bug 可能会出现，这种 bug 难以复现，而且难以排查。所以编程时需要谨慎地设计，以确保程序能够在所有时许条件下正常运行。

    多线程编程，还存在四大陷阱，一不小心就可能落入陷阱之中：
	1.死锁
	2.饿锁
	3.活锁
	4.竞态条件

二.进程 ID 和 线程 ID
    在 Linux 中，目前的线程实现是 Native POSIX Thread Library，简称 NPTL。在这种实现中线程又被称为轻量级进程，每一个用户态的线程在内核中都对应一个调度
实体，也拥有自己的进程描述符（task_struct 结构体）。
    没有线程之前，一个进程对应内核里的一个进程描述符，对应一个进程 ID。但是引入了线程的概念之后，情况发生了变化，一个用户进程下有 N 个用户态线程，每个
线程作为独立的调度实体在内核中都有自己的进程描述符，用户进程和内核里的进程描述符变成 1 ：N 的关系，POSIX 标准要求进程内的所有线程调用 getpid 时返回相同
的进程 ID。如何解决上述问题呢？
    内核引入了线程组的概念。

    struct task_struct{
    ...
    pid_t pid;
    pid_t tgid;
    ...
    struct task_struct *group_leader;
    ...
    struct list_head thread_group;
    ...
    }

    多线程的进程，又被称为线程组，线程组内的每一个线程在内核中都存在一个进程描述符与之对应。进程描述符结构体中的 pid，对应的是线程 ID，进程描述符中的 
tgid，含义是 Thread Group ID，该值对应的是用户层面的进程 ID。
    这里的线程 ID，不同于后面会讲到的 pthread_t 类型的线程 ID，和进程 ID 一样，线程 ID 是 pid_t 类型的变量，而且是用来唯一标识线程的一个整形变量。
    
    查看线程 ID：
    UID         PID   PPID    LWP  C NLWP STIME TTY          TIME CMD
    ...
    root        786      1    786  0    3 17:40 ?        00:00:00 /usr/sbin/ModemManager
    root        786      1    797  0    3 17:40 ?        00:00:00 /usr/sbin/ModemManager
    root        786      1    809  0    3 17:40 ?        00:00:00 /usr/sbin/ModemManager
    ...
    ps 命令中的 -L 选项，会显示出线程的如下信息：
    	1.LWP：线程 ID，即 gettid() 系统调用的返回值
    	2.NLWP：线程组内线程的个数

    已知某进程的进程 ID，该如何查看该进程内线程的个数及线程 ID 呢？其实可以通过 /proc/PID/task/ 目录下的子目录来查看，因为 procfs 在 task 目录下会给进程
的每个线程建立一个子目录，目录名为线程 ID。

    [lonzo@bogon ~]$ ll /proc/786/task/
    total 0
    dr-xr-xr-x. 6 root root 0 Oct  2 18:21 786
    dr-xr-xr-x. 6 root root 0 Oct  2 18:21 797
    dr-xr-xr-x. 6 root root 0 Oct  2 18:21 809

    对于线程，Linux 提供了 gettid 系统调用来返回线程 ID，可惜的是 glibc 并没有将该系统调用封装起来，再开放出接口来供我们使用。如果要获取线程 ID，可以采用
如下的代码块：
    
    #include <sys/syscall.h>
    syscall(SYS_gettid)

    线程组内的第一个线程，在用户态被称为主线程，在内核中被称为 Group Leader。内核在创建第一个线程时，会将线程组 ID 的值设置成第一个线程的线程 ID，
group_leader 指针则指向自身，即主线程的进程描述符。
    至于线程组其它线程的 ID 则由内核负责分配，其线程组 ID 总是和主线程的 ID 一致，无论是主线程直接创建的线程，还是创建出来的线程再次创建的线程，都是这样
    通过 group_leader 指针，每个线程都能找到主线程。主线程存在一个链表头，后面创建的每一个线程都会链入到该双向链表中。
    利用上述的结构，每个线程都可以轻松地找到其线程组的主线程，另一方面，通过线程组的主线程，也可以轻松地遍历其所有的组内线程（通过链表）。

    需要强调的一点是，线程和进程不一样，进程有父子进程的概念，但在线程组里所有的线程都是对等关系：
	1.并不是只有主线程才能创建线程，被创建出来的线程同样可以创建线程
 	2.不存在父子关系，大家都属于同一个线程组，进程 ID 都相等，group_leader 都指向主线程，而且各有各的线程 ID
	3.并非只有主线程才能调用 pthread_join 连接其他线程，同一线程组内的任何线程都可以对某线程执行 pthread_join 函数
	4.并非主线程才能调用 pthread_detach 函数，其实任意线程都可以对同一线程组内的线程执行分离操作 

