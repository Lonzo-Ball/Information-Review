    相对于 Unix 操作系统 40 多年的光辉历史，线程算是出现的比较晚的。在 20 世纪 90 年代线程才慢慢流行起来，而 POSIX threads 标准的确立已经是 1995 年的
事情了。
    Unix 原本是不支持线程的，线程概念的引入给 Unix 家族带来了一些麻烦，很多函数都不是线程安全的，需要重新定义，信号机制在线程加入以后也变得更加复杂了。
    在单核 CPU 时代，多线程的需求并没有那么强烈，但是随着时间流逝，处理器厂商改善 CPU 性能的传统方法，如提升时钟速度和指令吞吐量，基本已经走到了尽头，
处理器开始向超线程和多核架构靠拢，多核的时代已经来临。为了让代码运行的更快，单纯的依赖更快的硬件已经无法满足要求。程序员需要编写并发代码，以便充分发挥
多核处理器的强大功能，并且使程序的性能得到提高。

一.线程与进程
    在 Linux 下，程序或可执行文件是一个静态的实体，它只是一组指令的集合，没有执行的含义。进程是一个动态的实体，有自己的生命周期。线程是操作系统进程调度器
 可以调度的最小执行单元。进程和线程的关系：
	1.单线程进程
	2.多线程进程
	3.多个单线程进程
	4.多个多线程进程
    一个进程可能包含多个线程，传统意义上的进程，不过是多线程的一个特例，即该进程只包含一个线程。

    Unix/Linux 原本的设计是没有线程的，Unix 系统包括 Linux 从设计上更倾向于使用进程，反倒是 Windows 因为创建进程的开销巨大，而更加钟爱线程。
    进程之间，彼此的地址空间是独立的，但是线程会共享内存地址空间，同一个进程的多个线程共享一份全局内存区域，包括初始化数据段、未初始化数据段和动态分配的
堆内存段。这种共享给线程带来了很多优势：
	1.创建线程花费的时间要小于创建进程花费的时间（创建进程需要拷贝页表）
	2.终止线程花费的时间要小于终止进程花费的时间
	3.线程之间上下文切换的开销要小于进程之间的上下文开销
	4.线程之间数据的共享比进程之间的共享要简单
	5.线程之间通信的代价低于进程之间通信的代价
    线程间的上下文切换，指的是同一个进程里不同线程之间发生的上下文切换。由于线程原本属于同一个进程，他们会共享地址空间，大量资源共享，切换的代价小于进程
之间切换的代价是自然而然的事情。

    CPU 是一种资源，如果一方面 CPU 资源大量闲置，处于 IDLE 状态，另一方面很多任务得不到及时的处理，处于排队等待状态，这就表明资源没有得到有效利用，本质上
是一种浪费。
    如果存在多个相同的任务，彼此之间并行不悖，互不依赖（或者依赖性很小），那么启动多个线程并发处理，是一个不错的选择。虽然对每个任务而言，处理的时间并
没有缩短，但是在相同时间内，处理了更多的任务。
    有很多程序天生就适合用多线程。将工作切分成多个模块，并为每个模块分配一个或多个执行单元，更符合人类解决问题的思路。
    以文本编辑程序为例，用户的输入需要及时响应，必须要有线程来监控鼠标和键盘；如果用户删除了某一行，后面很多页的格式都会收到影响，这时就需要有文本格式化
程序在后台执行格式处理；很多文本编辑软件都有自动保存的功能，第三个线程会周期性地将文件内容写入磁盘；很多文本编辑软件都有检测拼写错误的功能，或许我们需要
第四个线程...

    目前存在的并发编程，基本可以分为两类：
	1.共享状态时
	2.消息传递式
    线程模型采用的是第一种。
    
    多线程带来优势的同时，也存在一些弊端：
	1.多线程的进程，因地址空间的共享让该进程变得更加脆弱
 	    多个线程之中，只要有一个线程不够健壮存在 bug，就会导致进程内的所有线程一起完蛋
  	    相比之下，进程的地址空间相互独立，彼此隔离的更加彻底。多个进程之间互相协同，一个进程存在 bug 导致异常退出，不会影响其它进程
	2.线程模型作为一种并发的编程模型，效率并没有想象的那么高，会出现复杂度高、易出错、难以测试和定位的问题
	    首先，多个线程之间，存在负载均衡的问题，现实中很难将全部任务等分给每个线程
	    其次，多个线程的任务之间还可能存在顺序依赖的关系，一个线程未完成某些操作之前，其它线程不能或不应该运行

    多个线程之间需要同步。多个线程生活在进程地址空间这个屋檐下，若存在多个线程操作共享资源，则需要同步，否则可能会出现结果错误、数据结构遭到破坏甚至是
程序崩溃等后果。因此多线程编程中存在临界区的概念，临界区的代码只允许一个线程执行，线程提供了锁机制来保护临界区。当其他线程来到临界区却无法申请到锁时，
就可能陷入阻塞，不再处于可执行状态，线程可能不得不让出 CPU 资源。如果设计不合理，临界区非常多，线程之间的竞争异常激烈，频繁的上下文切换也会导致性能急剧
恶化。
    多线程模型的复杂度更是不容小瞧。很多人诟病多线程模型，就在于它不符合人的心智模型。人很难同时控制多条走走停停，彼此又有交互和同步的执行流。由于进程
调度的无序性，严格来说多线程程序的每次执行其实并不一样，很难穷举所有的时许组合，所以我们永远无法宣称多线程的程序经过了充分的测试。在某些特殊时许的条件下
bug 可能会出现，这种 bug 难以复现，而且难以排查。所以编程时需要谨慎地设计，以确保程序能够在所有时许条件下正常运行。

    多线程编程，还存在四大陷阱，一不小心就可能落入陷阱之中：
	1.死锁
	2.饿锁
	3.活锁
	4.竞态条件

二.进程 ID 和 线程 ID
    在 Linux 中，目前的线程实现是 Native POSIX Thread Library，简称 NPTL。在这种实现中线程又被称为轻量级进程，每一个用户态的线程在内核中都对应一个调度
实体，也拥有自己的进程描述符（task_struct 结构体）。
    没有线程之前，一个进程对应内核里的一个进程描述符，对应一个进程 ID。但是引入了线程的概念之后，情况发生了变化，一个用户进程下有 N 个用户态线程，每个
线程作为独立的调度实体在内核中都有自己的进程描述符，用户进程和内核里的进程描述符变成 1 ：N 的关系，POSIX 标准要求进程内的所有线程调用 getpid 时返回相同
的进程 ID。如何解决上述问题呢？
    内核引入了线程组的概念。

    struct task_struct{
    ...
    pid_t pid;
    pid_t tgid;
    ...
    struct task_struct *group_leader;
    ...
    struct list_head thread_group;
    ...
    }

    多线程的进程，又被称为线程组，线程组内的每一个线程在内核中都存在一个进程描述符与之对应。进程描述符结构体中的 pid，对应的是线程 ID，进程描述符中的 
tgid，含义是 Thread Group ID，该值对应的是用户层面的进程 ID。
    这里的线程 ID，不同于后面会讲到的 pthread_t 类型的线程 ID，和进程 ID 一样，线程 ID 是 pid_t 类型的变量，而且是用来唯一标识线程的一个整形变量。
    
    查看线程 ID：ps -eLf
    UID         PID   PPID    LWP  C NLWP STIME TTY          TIME CMD
    ...
    root        786      1    786  0    3 17:40 ?        00:00:00 /usr/sbin/ModemManager
    root        786      1    797  0    3 17:40 ?        00:00:00 /usr/sbin/ModemManager
    root        786      1    809  0    3 17:40 ?        00:00:00 /usr/sbin/ModemManager
    ...
    ps 命令中的 -L 选项，会显示出线程的如下信息：
    	1.LWP：线程 ID，即 gettid() 系统调用的返回值
    	2.NLWP：线程组内线程的个数

    已知某进程的进程 ID，该如何查看该进程内线程的个数及线程 ID 呢？其实可以通过 /proc/PID/task/ 目录下的子目录来查看，因为 procfs 在 task 目录下会给进程
的每个线程建立一个子目录，目录名为线程 ID。

    [lonzo@bogon ~]$ ll /proc/786/task/
    total 0
    dr-xr-xr-x. 6 root root 0 Oct  2 18:21 786
    dr-xr-xr-x. 6 root root 0 Oct  2 18:21 797
    dr-xr-xr-x. 6 root root 0 Oct  2 18:21 809

    对于线程，Linux 提供了 gettid 系统调用来返回线程 ID，可惜的是 glibc 并没有将该系统调用封装起来，再开放出接口来供我们使用。如果要获取线程 ID，可以采用
如下的代码块：
    
    #include <sys/syscall.h>
    syscall(SYS_gettid)

    线程组内的第一个线程，在用户态被称为主线程，在内核中被称为 Group Leader。内核在创建第一个线程时，会将线程组 ID 的值设置成第一个线程的线程 ID，
group_leader 指针则指向自身，即主线程的进程描述符。
    至于线程组其它线程的 ID 则由内核负责分配，其线程组 ID 总是和主线程的 ID 一致，无论是主线程直接创建的线程，还是创建出来的线程再次创建的线程，都是这样
    通过 group_leader 指针，每个线程都能找到主线程。主线程存在一个链表头，后面创建的每一个线程都会链入到该双向链表中。
    利用上述的结构，每个线程都可以轻松地找到其线程组的主线程，另一方面，通过线程组的主线程，也可以轻松地遍历其所有的组内线程（通过链表）。

    需要强调的一点是，线程和进程不一样，进程有父子进程的概念，但在线程组里所有的线程都是对等关系：
	1.并不是只有主线程才能创建线程，被创建出来的线程同样可以创建线程
 	2.不存在父子关系，大家都属于同一个线程组，进程 ID 都相等，group_leader 都指向主线程，而且各有各的线程 ID
	3.并非只有主线程才能调用 pthread_join 连接其他线程，同一线程组内的任何线程都可以对某线程执行 pthread_join 函数
	4.并非主线程才能调用 pthread_detach 函数，其实任意线程都可以对同一线程组内的线程执行分离操作 

三.线程的创建和标识
1.pthread_create 函数

    pthread 库提供了如下接口来创建线程：
    	#include <pthread.h>
    	int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);

    pthread_create 函数的第一个参数是 pthread_t 类型的指针，线程创建成功的话，会将分配的线程 ID 填入该指针指向的地址。线程的后续操作将使用该值作为线程的
唯一标识。
    第二个参数是 pthread_attr_t 类型的指针，通过该参数可以定制线程的属性，比如可以指定新建线程栈的大小、调度策略等。如果创建线程无特殊要求，该值也可以是
NULL，标识采用默认属性。
    第三个参数是线程需要执行的函数。创建线程，是为了让线程执行一定的任务。线程创建成功之后，该线程就会执行 start_routine 函数，该函数之于线程，就如同 
main 函数之于主线程。
    第四个参数是新建线程执行的 start_routine 函数的参数。

    新建线程如果想要正常工作，则可能需要入参，那么主线程在调用 pthread_create 的时候，就可以将入参的指针放入第四个参数以传递给新建线程。
    如果线程的执行函数 start_routine 需要很多入参，传递一个指针就能提供足够的信息吗？答案是能。线程创建者和线程约定一个结构体，创建者便把信息填入该结构体
，再将结构体的指针传递给子进程，子进程只要解析该结构体，就能取出需要的信息。

    如果成功，pthtread_create 返回 0；如果不成功，则 pthread_create 返回一个非 0 的错误码。常见的错误码有：
	1.EAGAIN：系统资源不够，或者创建线程的个数超过了系统对一个进程中线程总数的限制
	2.EINVAL：第二个参数 attr 值不合法
	3.EPERM：没有合适的权限来设置调度策略或参数
    pthread_create 函数的返回情况有些特殊，通常情况下，函数调用失败，则返回 -1，并且设置 errno。pthread_create 函数则不同，它会将 errno 作为返回值，而不
是一个负值。

2.线程 ID 及进程地址空间布局
    pthread_create 函数，会产生一个线程 ID，存放在第一个参数指向的地址中。该线程 ID 和 pid_t 类型的线程 ID 是一回事吗？
    答案是否定的。
    pid_t 类型的线程 ID，属于进程调度范畴。因为线程是轻量级进程，是操作系统调度的最小单位，所以需要一个数值来唯一标识该线程。
    pthread_create 函数产生并记录在第一个参数指向地址中的线程 ID，属于 NPTL 线程库的范畴，线程的后续操作，就是根据该线程 ID 来操作线程的。

    线程库 NPTL 提供了 pthread_self 函数，可以获取到线程自身的 ID：
	#include <pthread.h>
	pthread_t pthread_self(void);

    在同一个线程组内，线程库提供了 pthread_equal 函数，可以判断两个线程 ID 是否对应着同一个线程：
	#include <pthread.h>
	int pthread_equal(pthread_t t1, pthread_t t2);
    返回值是 0 的时候，表示两个线程是同一个线程，非零值则表示不是同一个线程。

    pthread_t 到底是个什么样的数据结构呢？因为 POSIX 标准并没有限制 pthread_t 的数据类型，所以该类型取决于具体的实现。对于 Linux 目前使用的 NPTL 实现而言
，pthread_t 类型的线程 ID，本质就是一个进程地址空间上的地址。

