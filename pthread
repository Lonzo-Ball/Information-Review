    相对于 Unix 操作系统 40 多年的光辉历史，线程算是出现的比较晚的。在 20 世纪 90 年代线程才慢慢流行起来，而 POSIX threads 标准的确立已经是 1995 年的
事情了。
    Unix 原本是不支持线程的，线程概念的引入给 Unix 家族带来了一些麻烦，很多函数都不是线程安全的，需要重新定义，信号机制在线程加入以后也变得更加复杂了。
    在单核 CPU 时代，多线程的需求并没有那么强烈，但是随着时间流逝，处理器厂商改善 CPU 性能的传统方法，如提升时钟速度和指令吞吐量，基本已经走到了尽头，
处理器开始向超线程和多核架构靠拢，多核的时代已经来临。为了让代码运行的更快，单纯的依赖更快的硬件已经无法满足要求。程序员需要编写并发代码，以便充分发挥
多核处理器的强大功能，并且使程序的性能得到提高。

一.线程与进程
    在 Linux 下，程序或可执行文件是一个静态的实体，它只是一组指令的集合，没有执行的含义。进程是一个动态的实体，有自己的生命周期。线程是操作系统进程调度器
 可以调度的最小执行单元。进程和线程的关系：
	1.单线程进程
	2.多线程进程
	3.多个单线程进程
	4.多个多线程进程
    一个进程可能包含多个线程，传统意义上的进程，不过是多线程的一个特例，即该进程只包含一个线程。

    Unix/Linux 原本的设计是没有线程的，Unix 系统包括 Linux 从设计上更倾向于使用进程，反倒是 Windows 因为创建进程的开销巨大，而更加钟爱线程。
    进程之间，彼此的地址空间是独立的，但是线程会共享内存地址空间，同一个进程的多个线程共享一份全局内存区域，包括初始化数据段、未初始化数据段和动态分配的
堆内存段。这种共享给线程带来了很多优势：
	1.创建线程花费的时间要小于创建进程花费的时间（创建进程需要拷贝页表）
	2.终止线程花费的时间要小于终止进程花费的时间
	3.线程之间上下文切换的开销要小于进程之间的上下文开销
	4.线程之间数据的共享比进程之间的共享要简单
	5.线程之间通信的代价低于进程之间通信的代价
    线程间的上下文切换，指的是同一个进程里不同线程之间发生的上下文切换。由于线程原本属于同一个进程，他们会共享地址空间，大量资源共享，切换的代价小于进程
之间切换的代价是自然而然的事情。

    CPU 是一种资源，如果一方面 CPU 资源大量闲置，处于 IDLE 状态，另一方面很多任务得不到及时的处理，处于排队等待状态，这就表明资源没有得到有效利用，本质上
是一种浪费。
    如果存在多个相同的任务，彼此之间并行不悖，互不依赖（或者依赖性很小），那么启动多个线程并发处理，是一个不错的选择。虽然对每个任务而言，处理的时间并
没有缩短，但是在相同时间内，处理了更多的任务。
    有很多程序天生就适合用多线程。将工作切分成多个模块，并为每个模块分配一个或多个执行单元，更符合人类解决问题的思路。
    以文本编辑程序为例，用户的输入需要及时响应，必须要有线程来监控鼠标和键盘；如果用户删除了某一行，后面很多页的格式都会收到影响，这时就需要有文本格式化
程序在后台执行格式处理；很多文本编辑软件都有自动保存的功能，第三个线程会周期性地将文件内容写入磁盘；很多文本编辑软件都有检测拼写错误的功能，或许我们需要
第四个线程...

    目前存在的并发编程，基本可以分为两类：
	1.共享状态时
	2.消息传递式
    线程模型采用的是第一种。
    
    多线程带来优势的同时，也存在一些弊端：
	1.多线程的进程，因地址空间的共享让该进程变得更加脆弱
 	    多个线程之中，只要有一个线程不够健壮存在 bug，就会导致进程内的所有线程一起完蛋
  	    相比之下，进程的地址空间相互独立，彼此隔离的更加彻底。多个进程之间互相协同，一个进程存在 bug 导致异常退出，不会影响其它进程
	2.线程模型作为一种并发的编程模型，效率并没有想象的那么高，会出现复杂度高、易出错、难以测试和定位的问题
	    首先，多个线程之间，存在负载均衡的问题，现实中很难将全部任务等分给每个线程
	    其次，多个线程的任务之间还可能存在顺序依赖的关系，一个线程未完成某些操作之前，其它线程不能或不应该运行

    多个线程之间需要同步。多个线程生活在进程地址空间这个屋檐下，若存在多个线程操作共享资源，则需要同步，否则可能会出现结果错误、数据结构遭到破坏甚至是
程序崩溃等后果。因此多线程编程中存在临界区的概念，临界区的代码只允许一个线程执行，线程提供了锁机制来保护临界区。当其他线程来到临界区却无法申请到锁时，
就可能陷入阻塞，不再处于可执行状态，线程可能不得不让出 CPU 资源。如果设计不合理，临界区非常多，线程之间的竞争异常激烈，频繁的上下文切换也会导致性能急剧
恶化。
    多线程模型的复杂度更是不容小瞧。很多人诟病多线程模型，就在于它不符合人的心智模型。人很难同时控制多条走走停停，彼此又有交互和同步的执行流。由于进程
调度的无序性，严格来说多线程程序的每次执行其实并不一样，很难穷举所有的时许组合，所以我们永远无法宣称多线程的程序经过了充分的测试。在某些特殊时许的条件下
bug 可能会出现，这种 bug 难以复现，而且难以排查。所以编程时需要谨慎地设计，以确保程序能够在所有时许条件下正常运行。

    多线程编程，还存在四大陷阱，一不小心就可能落入陷阱之中：
	1.死锁
	2.饿锁
	3.活锁
	4.竞态条件

