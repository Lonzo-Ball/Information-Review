OSI 七层模型：开放式系统互联参考模型，是一个逻辑上的定义和规范
    应用层
    表示层
    会话层
    传输层
    网络层
    数据链路层
    物理层

TCP/IP 五层模型：
   一. 应用层  负责应用程序间沟通 网络远程访问协议Telnet、远程登录协议SSH、文件传输协议ftp、简单电子邮件传输协议SMTP
	1.自定制协议
	    序列化：将结构化数据或对象转换为二进制数据串
	    反序列化：将内存中的二进制数据串转化为结构化数据或对象

	2.HTTP协议 超文本传输协议 明文字符串传输
	    1.URL 统一资源定位符
	    http://user:pass@www.msn.cn:80/zh-cn?PC=MSSH&ocid=1PRCDEFE
		http 协议方案名
		user:pass 登录信息
		www.msn.cn:80 服务器地址+服务器端口号
		/zh-cn 资源路径 其中/是相对根目录
		PC=MSSH&ocid=1PRCDEFE 查询字符串/参数
	    urllencode 和 urldecode
	    2.HTTP协议格式
		1.HTTP请求
		首行：请求方法 + url + 协议版本
		    GET 更多用于获取资源 1.0、1.1  能够提交的url长度是有限的，最大长度根据游览器的不同也会有所不同
		    POST 更多用于提交资源 1.0、1.1  提交的数据在正文中，正文的长度是没有限制的
		    PUT 传输文件 1.0、1.1
   		    HEAD 获取报文首部 1.0、1.1
		    DELETE 删除文件 1.0、1.1
		    OPTIONS 询问支持的方法 1.1
		    TRACE 追踪路径 1.1
		    CONNECT 要求用隧道协议连接代理 1.1
		    LINK 建立和资源之间的联系 1.0
		    UNLINK 断开连接关系 1.0
		报头：请求的属性，冒号分割的键值对 每组属性之间使用\r\n分割 遇到空行表示报头部分结束
		    Content-Length 正文长度
                    Content-Type 数据类型
		    Host 客户端告知服务器，所请求的资源是在哪个主机的哪个端口上
		    User-Agent 申明用户的操作系统以及游览器的版本信息
		    Cookie 用于在客户端存储少量信息
		    Accept 告诉对方我能接受的数据/资源类型
		    Accept-Encoding 浏览器发给服务器,声明浏览器支持的编码类型 如gzip
		    Accept-Language 客户端声明它可以理解的自然语言
		    Referer 当前网页是从哪个网站跳转过来的
		空行：
		正文：空行后面的内容就是正文 正文允许为空字符串 如果正文存在，则在报头中会有一个Content-Length属性来标识正文长度
		2.HTTP响应
		首行：协议版本 + 状态码 + 状态码描述
		    1XX 信息性状态码 接受的请求正在处理
		    2XX 成功状态码 请求正常处理完毕
			200 OK
		    3XX 重定向状态码 需要进行附加操作以完成请求
			301 永久性重定向
			302 临时性重定向
			Location 告诉客户端接下来去哪里访问
		    4XX 客户端错误状态码 服务器无法处理请求
			403 服务器拒绝了你的地址请求，很有可能是你根本就没权限访问网站
			404 无法找到资源
		    5XX 服务器错误状态码 服务器处理请求出错
		报头：响应的属性，冒号分割的键值对 每组属性之间使用\r\n分割 遇到空行表示报头部分结束
		    Transfer-Encoding 分多次响应请求资源时，标识当前发送的资源大小
		空行：
		正文：空行后面的内容就是正文 正文允许为空字符串 如果正文存在，则在报头中会有一个Content-Length属性来标识正文长度
		      如果服务器返回一个HTML页面，那么HTML页面内容就在正文中

	3.GET /favicon.ico HTTP/1.1  请求网站头像
	4.http与https 的区别
 	5.https是如何完成加密的
    二.传输层  负责端与端之间的数据传输，如传输控制协议TCP，能够确保数据可靠的从源主机发送到目的主机 TCP/UDP
	1.UDP协议
	    1.UDP协议格式
		16位UDP长度，表示整个数据报（UDP首部+UDP数据）的最大长度 65535字节 
		如果校验和出错，就会直接丢弃 二进制反码求和
	    2.UDP的特点
   		无连接：知道对端的IP和端口号就直接进行传输，不需要建立连接
		不可靠：没有确认机制，没有重传机制 如果因为网络故障该段无法发送到对端，UDP协议层也不会给应用层返回任何错误信息
		面向数据报
		    1.数据是一整条一整条发送和接受的，不能够灵活控制读写数据的次数和数量
		    2.应用层交给UDP多长的报文，UDP原样发送，既不会拆分，也不会合并
		    3.用UDP传输100个字节的数据：如果发送端调用一次sendto，那么接收端也必须调用对应的一次recvfrom，接受100个字节，
		      而不能循环调用10次recvfrom，每次接受10个字节
 	    3.UDP的缓冲区
		UDP没有真正意义上的发送缓冲区，调用sendto会直接交给内核，由内核将数据交给网络层协议进行后续的传输动作
		UDP具有接受缓冲区，但是这个接受缓冲区不能保证收到的UDP报的顺序和发送的UDP报的顺序一致 如果缓冲区满了，再到达的UDP
		数据就会被丢弃
	    4.UDP使用注意事项
		一个UDP能传输的数据最大长度是64k，然而64k在当今互联网下是一个非常小的数字，如果我们需要传输的数据超过64k，就需要在
		应用层手动分包，多次发送，并在接收端手动拼装
	    5.基于UDP的应用层协议
		DNS 域名解析协议
		DHCP 动态主机配置协议
		NFS 网络文件系统
		TFTP 简单文件传输协议
		BOOTP 启动协议
	2.TCP协议 传输控制协议  既要保证可靠性，又尽可能的提高性能，所以TCP复杂呀！
	    1.TCP协议格式
		16位源/目的端口号：表示数据是从哪个进程来，到哪个进程去
		32位序号/确认序号：
		4位TCP报头长度：表示TCP头部有多少个32位bit，所以TCP头部的最大长度是 15*4 = 60 字节
		6位标志位
		    URG：紧急指针是否有效
		    ACK：确认号是否有效
		    PSH：提示接收端应用程序立即从TCP缓冲区把数据读走
		    RST：对方要求重新建立连接 我们把携带RST标识的报文段称为复位报文段
		    SYN：请求建立连接 我们把携带SYN标识的报文段称为同步报文段
		    FIN：通知对方，本端要关闭了 我们把携带FIN标识的报文段称为结束报文段
		16位窗口大小：接收方缓冲区的剩余空间的大小
		16位检验和：发送端填充，CRC校验 接收端检验不通过，则认为数据有问题 此处的检验和不光包括TCP头部，也包括数据部分
		16位紧急指针：标识哪部分数据是紧急数据 和URG搭配使用
		40字节头部选项：
	    2.TCP 协议通信流程
		1.服务器初始化
         	    1.调用 socket，创建文件描述符
	            2.调用 bind，将当前描述符和 ip/port 绑定在一起（如果此处的端口号被其他进程占用了，绑定会失败）
	            3.调用 listen，申明当前这个文件描述符作为一个服务器的描述符，为后面的 accept 做好准备
	            4.调用 accept，并阻塞，等待客户端连接过来
		2.建立连接过程 通常称为三次握手
	            1.客户端调用 socket，创建文件描述符
                    2.客户端调用 connect，向服务器发起连接请求
                    3.connect 会发出 SYN 段并阻塞等待服务器应答（第一次）
                    4.服务器收到客户端的 SYN，就将该连接放入内核等待队列中，会应答一个 SYN-ACK 段表示“同意建立连接”（第二次） 
                    5.客户端收到 SYN-ACK 后会从 connect 返回，同时应答一个 ACK 段（第三次）

		    关于三次握手
			1.最小的成本，最大的概率，握手成功
			2.永远不可能可靠：最新的/最后的（回复应答的是可靠的）
			3.网络中没有 100% 保证连接成功的
			4.三次握手中最后ACK发送失败时，服务端直接关闭连接
			5.两次握手存在的问题：有可能空连接会挂在服务器端  "用资源维护连接"
			6.三次握手，空连接可能会挂在客户端，但几乎是没有影响的
			7.四次握手存在的问题：有可能空连接会挂在服务端
		3.数据传输的过程
	            1.建立连接后，TCP 协议提供全双工的通信服务。全双工的意思是，在同一条连接中，同一时刻，通信双方可以同时写数据；
		      相对的概念叫做半双工，在同一条连接中，同一时刻，只能由一方来写数据
		    2.服务器从 accept 返回后立即调用 read，读 socket 就像读管道一样，如果没有数据到达就阻塞等待
		    3.客户端调用 write 发送数据给服务器，服务器收到后从 read 返回，对客户端的请求进行处理，在此期间客户端调用 
		      read 阻塞等待服务器的应答
		    4.服务器调用 write 将处理结果发送给客户端，再次调用 read 阻塞等待下一条请求
		    5.客户端收到后从 read 返回，发送下一条请求，如此循环下去
		4.断开连接的过程 通常称为四次挥手
		    1.如果客户端没有更多的请求了，就调用 close 关闭连接，客户端会向服务器发送 FIN 段（第一次）
		    2.服务器收到 FIN 段后，会应答一个 ACK，同时 read 会返回 0（第二次）
		    3.从 read 返回后，服务器就知道客户端关闭了连接，也调用 close 关闭连接，服务器会向客户端发送一个 FIN（第三次）
		    4.客户端收到 FIN，进入TIME_WAIT状态，再返回一个 ACK 给服务器（第四次）
		    5.客户端要等待2MSL（报文最大生存时间）的时间后才会进入CLOSED状态

		    关于主动断开连接的一方进入TIME_WAIT状态，等2MSL时间后才进入CLOSE状态
			1.测试：首先启动server，然后启动client，然后用Ctrl-c使server终止，这时马上再运行server，结果是：bind error
			  这是因为，虽然server的应用程序终止了，但TCP协议层的连接并没有完全断开，因此不能监听同样的server端口
			2.关于MSL时间，各操作系统实现不同，在Centos7上默认配置的是60s

			3.MSL是TCP报文的最大生存时间，TIME_WAIT持续存在2MSL时间的话
			4.一定程度上保证在两个传输方向上尚未被接受或迟到的报文段都已经消失/到达对端（否则服务器立即重启，可能会收
			  到来自上一个进程的迟到的数据，但是这种数据是错误的）
			5.同时也是在理论上保证最后一个报文可靠到达（假设最后一个ACK丢失，那么服务器会重发一个FIN，这时虽然客户端的
			  进程不在了，但是TCP连接还在，仍然可以重发LAST_ACK），否则最后ACK失败的话，服务端挂的连接很多

		    解决TIME_WAIT状态引起的bind失败的方法
		    在server的TCP连接没有完全断开之前不允许重新监听，某些情况下可能是不合理的
			1.服务器需要处理非常大量的客户端的连接（每个连接的生存时间可能很短，但是每秒都有很大数量的客户端请求）
			2.这个时候如果由服务器端主动关闭连接（比如某些客户端不活跃，就需要被服务器端主动清理掉），就会产生大量的
			  TIME_WAIT连接
			3.由于我们的请求量很大，就可能导致TIME_WAIT的连接数很多，导致服务器的端口不够用，无法处理新的请求

			4.使用setsockopt函数设置socket描述的选项SO_REUSEADDR为1
			  int opt_ = 1;
			  setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &opt_, sizeof(opt_));

		5.在学习 socket API 是要注意应用程序和 TCP 协议层是如何交互的
		    1.应用程序调用某个 socket 函数时 TCP 层完成了什么动作，比如调用 connect 会发送 SYN 段
		    2.应用程序如何知道 TCP 层的状态变化，比如从某个阻塞的 socket 函数返回就表明 TCP 协议收到了某些段、read 返回 0
		      就表明收到了FIN 段
	    3.TCP保证可靠传输的机制
		1.检验和
		2.序列号（保证正确的顺序）
		3.确认应答机制
		  每一个ACK都带有对应的确认序列号，意思是告诉发送者，我已经收到了哪些数据，下一次你从哪里开始发
		4.超时重传机制
		  主机A发送数据给B之后，可能因为网络拥塞等原因，数据无法到达主机B
		  如果主机A在一段特定时间间隔内没有收到主机B发来的确认应答，就会进行重发

		  但是，主机A未收到B发来的确认应答，也可能是因为ACK丢失了
		  因此主机B会收到很多重复数据。那么TCP协议需要能够识别出哪些报是重复的报，并且把重复的报丢弃，这个时候可以利用序列
		  号，就可以很容易做到去重

		  超时重传的时间如何确定？
		      最理想的情况下，找到一个最小的时间，保证确认应答一定能在这个时间内返回
	 	      但是这个时间的长短，随着网络环境的不同，是有差异的
		      如果超时重传时间设的太长，会影响整体的重传效率
		      如果超时重传时间设的太短，有可能会频繁发送重复的报

		  TCP为了保证无论在任何环境下都能比较高性能的通信，因此会动态计算这个最大超时时间
		      Linux中超时重传时间以500ms为一个单位进行控制，每次判定超时重传的时间都是500ms的整数倍
		      如果重传一次之后，仍然得不到应答，等待2*500ms后再次进行重传
		      如果仍然得不到应答，等待4*500ms后进行重传，一次类推，以指数形式递增
		      累积到一定的重传次数，TCP认为网络或者对端主机出现异常，强制关闭连接
		5.基于滑动窗口的快重传机制
	    4.TCP提高性能的机制
	      TCP因为要保证可靠传输，因此性能有很大的消耗，为了一定程度上提高TCP的传输性能，又提出了一些机制
		1.滑动窗口
		  窗口大小指的是无需等待确认应答而可以继续发送数据的最大值
		  收到第一个ACK后，滑动窗口向后移动，继续发送第五个段的数据，依此类推
		  操作系统为了维护这个滑动窗口，需要开辟发送缓冲区，来记录当前还有哪些数据没有应答，只有确认应答过的数据，才能从缓
		  冲区删掉
	 	  窗口越大，则网络的吞吐率就越高

		  如果数据包已经到达，ACK丢弃了，这种情况下部分ACK丢弃并不要紧，因为可以通过后续的ACK进行确认
		2.基于滑动窗口的快重传机制
		  如果发送方没有接收到第一条数据的ACK，但是接收到了第二条数据的ACK，那么就认为第一条数据也发送成功了，不需要重传
   		  当某一段报文段(比如：1001-2000)丢弃之后，发送端会一直收到 1001 这样的ACK，就像是在提醒发送端“我想要的是1001”一样
		  如果发送端主机连续三次收到一样的ACK，就会将对应的数据(1001-2000)重发
		  这个时候接收端收到 1001-2000 之后，再次返回的ACK就是7001了，因为(2001-7000)接收端其实之前就已经收到了，被放到了
		  接收端操作系统内核的接受缓冲区中
		  这种机制被称为快重传
		3.流量控制
		  接收端处理数据的速度是有限的，如果发送端发的太快，导致接收端的缓冲区被放满，这个时候，如果发送端继续发送，就会造
		  成丢包，继而引起丢包重传等一些列连锁反应
		  因此TCP支持根据接收端的处理能力，来决定发送端的发送速度，这个机制就叫做流量控制
		      接受端将自己可以接受数据的缓冲区的大小放入TCP首部中“窗口大小”字段，通过ACK通知发送端
		      窗口大小越大，说明网络的吞吐率越高
		      接收端一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值通知给发送端
		      发送端接收到这个窗口大小之后，就会减缓自己的发送速度
		      如果接收端缓冲区满了，就会将窗口大小设置为0，这时发送方不再发送数据，但是定期需要发送一个窗口探测数据段，使
		      接收端把窗口大小告诉发送端
		      窗口探测 窗口更行通知

		  问题来了，窗口大小字段为16位，16位最大表示65536，那么TCP窗口最大就是65535字节吗？
		  实际上，TCP首部40字节选项中还包含了一个窗口扩大因子M，实际窗口大小是窗口字段的值左移M位
		4.拥塞控制
		  虽然TCP有了滑动窗口这个大杀器，能够高效可靠的发送大量的数据，但是如果在刚开始阶段就发送大量的数据，仍然可能引发
		  问题
		  因为网络上有很多的计算机，可能当前的网络状态就已经比较拥堵，在不清楚当前网络状态下，贸然发送大量的数据，是非常不
		  合理的
		  
		  TCP引入慢启动机制，先发少量的数据，探探路，摸清当前的网络拥堵状态，再决定按照多大的速度传输数据
		      此处引入一个概念为拥塞窗口
		      发送开始的时候，定义拥塞窗口大小为1
		      每次收到一个ACK应答，拥塞窗口加1
		      每次发送数据的时候，将拥塞窗口和接收端主机反馈的窗口大小做比较，取较小的值作为实际发送的窗口大小

		  像上面这样的拥塞窗口增长速度是指数级别的，“慢启动”只是初始值设的小，但是增长速度非常快
		      为了不增长的那么快，因此不能使拥塞窗口单纯的加倍
		      此处引入一个慢启动的阈值
		      当拥塞窗口超过这个阈值的时候，不再按指数方式增长，而是按照线性方式增长
		      当TCP开始启动的时候，慢启动阈值等于窗口最大值
		      在每次超时重发的时候，慢启动阈值变为原来的一般，同时拥塞窗口置回1

		  少量的丢包，我们仅仅是触发超时重传，大量的丢包，我们就认为网络拥塞
		  拥塞控制归根结底是TCP协议想尽可能快的把数据传输给对方，但是又要避免给网络造成太大压力的折中方案
		5.延迟应答
		  如果接收方主机立即回复ACK，这时候返回的窗口可能比较小
		      假设接收端缓冲区为1M，一次收到了500K的数据，如果立即应答，返回的窗口就是500K
		      但实际上接收端可能处理的速度比较快，10ms之内把500K的数据从缓冲区拿走了
		      在这种情况下，接收端处理还远没有达到自己的极限，即使窗口再放大一些，也能处理掉
		      如果接收端稍微等一会再应答，比如等待200ms再应答，那么这个时候返回的窗口大小就是1M

		  窗口越大，网络吞吐量就越大，传输效率就越高，我们的目标是在保证网络不拥塞的情况下经量提高传输数据量/效率
		  

		  关于延迟应答
		      数量限制：每隔N个包就应答一次
		      时间限制：超过最大延迟时间就应答一次
		  具体的数量和延迟时间，依操作系统不同会有差异，一般N取2，最大延迟时间取200ms
		6.捎带应答
		  在延迟应答的基础上，我们发现，很多情况下，客户端和服务端在应用层是“一发一收”的
		  那么这个时候ACK就可以搭顺风车，和服务器回应的数据一起回给客户端
	    5.TCP的特点
		创建一个TCP的socket，同时在内核中创建一个发送缓冲区和接受缓冲区
		    调用write，数据会先写入发送缓冲区
		    如果发送的字节数太长，会被拆分成多个TCP包发送出去
		    如果发送的字节数太短，就会在缓冲区里等待，等到缓冲区长度差不多了，或者其他合适的实际发送出去
		    接受数据的时候，数据也是从网卡驱动程序到内核的接收缓冲区
		    然后应用程序可以调用read从接受缓冲区拿数据
		    另一方面，TCP的一个连接，既有发送缓冲区，也有接受缓冲区，那么对于这一个连接，既可以读数据，也可以写数据，这个
		    概念叫做全双工

		由于缓冲区的存在，TCP程序的读和写不需要一一匹配
		    写100个字节的数据，可以调用一次write写100个字节，也可以调用100次write，每次写1个字节
		    读100个字节的时候，也完全不需要考虑写的时候是如何写的，既可以是一次 read 100个字节，也可以一次 read 1 个字节，
		    重复100次
	    6.粘包问题
		首先要明确，粘包问题中的“包”，指的是应用层的数据包
		在TCP的协议头当中，没有如同UDP一样的“报文长度”这样的字段，但是有一个序号这样的字段
		站在传输层的角度，TCP是一个包一个包过来的，按照序号排好序放在缓冲区中
		站在应用层的角度，看到的只是一串连续的字节数据
		那么应用程序看到了这么一连串的字节数据，就不知道从哪个部分到哪个部分，是一个完整的应用层数据包

		那么如何避免粘包问题？  归根结底就是一句话：明确两个包之间的边界
		    1.对于定长的包，保证每次都按固定大小读取数据  自定制协议
		    2.对于变长的包，可以在包头位置，约定一个包总长度字段，从而就知道了包的结束位置
		      对于变长的包，还可以在包和包之间使用明确的分隔符（只要保证分隔符不和正文冲突就可以）

		对于UDP协议来说，是否也存在粘包问题？
		    参考UDP面向数据包的特性
		    站在应用层的角度，使用UDP的时候，要么收到完整的UDP报文，要么不收，不会出现“半个”的情况
	    7.基于TCP的应用层协议
		HTTP
		HTTPS
		SSH
		Telnet
		FTP
		SMTP   

	3.TCP 和 UDP 对比
	    1.可靠传输 不可靠传输
	    2.有连接 无连接
	    3.面向字节流 面向数据报

	    TCP用于可靠传输的情况，应用于文件传输、重要状态更新等场景
	    UDP用于高速传输和实时性要求比较高的通信领域

	    用UDP实现可靠传输（经典面试题）
	    参考TCP的可靠传输机制，在应用层实现类似的逻辑
		引入序列号，保证数据顺序
	 	引入确认应答，保证对端收到了数据
		引入超时重传，如果隔一段时间没有应答，就重发数据
		......
    三.网络层  负责地址管理和路由选择，如IP协议中，通过 ip 地址来标识一台主机，并通过路由表的方式规划出两台主机之间数据传输的线路
            路由器 IP协议、ICMP、IGMP
	1.协议头格式
	    4位版本号：指定ip协议的版本，对IPV4来说，就是4
	    4位头部长度：IP头部长度是多少个4字节，4bit表示的最大的数字是15，因此IP头部最大长度是60字节
	    8位服务类型
		3位优先权字段 已经弃用
		4位TOS字段，分别表示最小延时、最大吞吐量、最高可靠性、最小成本。这四者相互冲突，只能选择一个。对于SSH/Telnet这样的
		应用程序，最小延时比较重要，对于FTP这样的程序，最大吞吐量比较重要
		1位保留字段 必须置为0
	    16位总长度：IP数据报整体的字节数
	    16位标识：唯一的标识主机发送的报文，如果IP报文在数据链路层被分片了，那么每一个片里面的这个id都是一样的
	    3位标志
		第一位保留
		第二位置为1，表示禁止分片，这时候如果报文长度超过MTU，就会丢弃IP数据报
		第三位类似于一个分片结束标记，如果分片了的话，最后一个分片置为0，其他是1
	    13位分片偏移：是分片相对于原始IP报文开始处的偏移值，其实就是在标记当前分片在原报文中处在哪个位置，实际偏移的字节数是这
	    个值*8得到的，因此，除了最后一个报文之外，其他报文必须是8的整数倍
	    8位生存时间（TTL）：数据报到达目的地的最大跳数，一般是64，每次经过一个路由器 TTL -= 1，一直减到0还没到达就丢弃报文，这
	    个字段主要是用来防止出现路由循环

	    8位协议类型：表示上层协议的类型
	    16位检验和：使用CRC进行校验，来鉴别头部是否损坏
	    32位源IP地址和32位目的IP：表示发送端和接收端
	    选项字段：最多40字节
	2.网段划分  
	    ip地址分为两个部分
		网络号：保证相互连接的两个网段具有不同的标识
		主机号：同一网段内主机之间具有相同的网络号，但是必须有不同的主机号	
		不同的子网其实就是把网络号相同的主机放到一起
		如果在子网中新增一台主机，则这个主机的网络号和这个子网的网络号一致，但是主机号必须不能和子网中的其他主机重复
	    通过合理设置主机号和网络号，就可以保证在相互连接的网络中，每台主机的IP地址都不同

	    如何管理子网内的IP？
		有一种技术叫做DHCP，能够自动的给子网内新增主机结点分配IP地址，避免了手动管理IP的不便
		一般的路由器都带有DHCP功能，因此路由器也可以看作一个DHCP服务器

	    过去曾经提出一种划分网络号和主机号的方案，把所有IP地址分为5类
	    随着internet的飞速发展，这种划分方案的局限性很快显现出来，大多数组织都申请B类地址，导致B类地址很快就分配完了，而A类却
	    浪费了大量的地址
		例如，申请一个B类地址，理论上一个子网内能允许有6万5千多台主机 A类地址的子网内主机数更多
		然而实际网络架构中，不会存在一个子网内有这么多台主机的情况，因此大量的IP地址都被浪费掉了
	    针对这种情况提出了新的划分方案，称为CIDR
		引入一个额外的子网掩码来区分网络号和主机号
		子网掩码也是一个32位的正整数，通常用一串 0 来结尾
		将IP地址和子网掩码进行按位与操作，得到的结果就是网络号 主机号从 0 到全 1 就是子网的范围
		网络号和主机号的划分与这个IP地址是A类、B类还是C类无关
	    	IP地址和子网掩码还有一种更简洁的表示方法，例如：140.252.20.68/24，表示IP地址为：140.252.20.68，该网段的子网掩码为
		255.255.255.0
	3.特殊的IP地址
	    将IP地址中的主机号全部设为0，就成为了网络号，代表这个局域网
	    将IP地址中的主机号全部设为1，就成了广播地址，用于给同一链路中相互连接的所有主机发送数据报
	    127.*的IP地址用于本地环回测试，通常是127.0.0.1
	4.IP地址的数量限制
	    IPV4是一个32位的正整数，一共只有2的32次方个IP地址，大概是43亿左右，而TCP/IP协议规定，每个主机都需要一个IP地址

	    一共只有43亿台主机能接入网络吗
	    	实际上，由于一些特殊IP地址的存在，数量远远不足43亿
		IP地址并非是按照主机台数来配置的，而是每一个网卡需要配置一个或多个IP地址

	    CIDR在一定程度上缓解了IP地址不够用的问题（提高了利用率，减少了浪费，但是IP地址的绝对上限并没有增加），仍然不够用，这时
	    候有三种方式来解决
		动态分配IP地址：只给接入网的设备分配IP地址，因此同一个MAC地址的设备，每次接入互联网中得到的IP地址是不一样的
		NAT技术
		IPV6:并不是IPV4的简单升级，这是互不相干的两个协议，彼此并不兼容。IPV6用128位来表示IP地址 但是目前还没有普及
	5.私有IP地址和公网IP地址
	    如果一个组织内部组建局域网，IP地址只用于局域网内的通信，而不直接连到Internet上，理论上使用任意的IP地址都可以，但是 RFC
	    1918 规定了用于组建局域网的私有IP地址
		10.*：前 8 位是网络号，共 16,777,576 个地址
		172.16 到 172.31：前 12 位是网络号，共 1,048,576 个地址
		192.168.*：前 16 位是网络号，共 65536 个地址
		包含在这个范围中的，都称为私有IP，其余的则称为全网 IP

		一个路由器可以配置两个IP地址，一个是WAN口IP，一个是LAN口IP
		路由器的LAN口连接的主机，都从属于当前这个路由器的子网中
		不同的路由器，子网IP其实都是一样的（通常都是192.168.1.1），子网内的主机IP地址不能重复，但是子网之间的主机IP地址就
		可以重复了
		每一个家用路由器，其实又作为运营商路由器的子网中的一个结点，这样的运营商路由器可能会有很多级，最外层的运营商路由器
		WAN口IP就是一个公网IP了
		子网内的主机需要和外网进行通信时，路由器将IP首部中的IP地址进行替换（替换成WAN口IP），这样逐级替换，最终数据包中的
		IP地址成为一个公网IP，这种技术成为NAT（网络地址转换）
		如果希望我们自己实现的服务器程序，能够在公网上被访问到，就需要把程序部署在一台具有外网的服务器上 这样的服务器可以
		在阿里云/腾讯云上进行购买
	6.路由  在复杂的网络结构中，找出一条通往终点的路线
	    IP数据报的传输过程和问路一样
		当IP数据报到达路由器时，路由器会先查看目的IP
		路由器决定这个数据报是能直接发送给目标主机，还是发送给下一个路由器
		依次反复，至到到达目的IP地址

	    那么如何判定当前这个数据报该发送到哪里呢？这个就依赖每个节点内部维护的路由表
		路由表可以使用route命令查看
		如果目的IP命中了路由表就直接转发即可
		当目的地址与路由表中的其他行都不匹配时，就按缺省路由条目规定的接口发送到下一跳地址
	7.路由表生成算法
	    路由表可以由网络管理员手动维护 静态路由
	    也可以通过一些算法自动生成 动态路由
		距离向量算法
		LS算法
		Dijkstra算法
    四.数据链路层  负责相邻设备之间数据帧的传送和识别 交换机 以太网、令牌环网、无线LAN
	1.以太网
	    1."以太网"不是一种具体的网络，而是一种技术标准。既包含了数据链路层的内容，也包含了一些物理层的内容
	    2.以太网的网线必须使用双绞线 传输速率有10M、100M、1000M等
	    3.以太网是当前应用最广泛的局域网技术 局域网技术还有令牌环网、无线LAN等
	2.以太网帧格式
	    源地址和目的地址指网卡的硬件地址（MAC地址），长度是48位
	    帧协议类型字段（2位）有三个可取值：IP、ARP、RARP
	    帧末尾是4位CRC校验
	3.MAC地址
	    用来识别数据链路层中相连的结点
	    长度是48位，即6个字节 一般是16进制数字加上冒号的形式来表示
	    在网卡出厂时就确定了，不能修改，MAC通常是唯一的
	    虚拟机中的MAC地址不是真实的MAC地址，可能会冲突
	4.MAC地址和IP地址
	    IP地址描述的是路途总体的起点和终点
	    MAC地址描述的是路途上每一个区间的起点和终点
	5.MTU
	    以太网帧中的数据长度规定最小46字节，最大1500字节 ARP数据报的长度不够46字节，要在后面补填充位
	    最大值1500称为以太网的最大传输单元，不同的网络类型/数据链路层标准有不同的MTU值
	    如果一个数据报从以太网路由到拨号链路上，数据报的长度大于拨号链路的MTU了，则需要对数据报进行分片处理

	    MTU对IP协议的影响  由于数据链路层MTU的限制，对于较大的数据包要进行分片
		1.将较大的数据包分成多个小包，并给每个小包打上标签
		2.每个小包IP协议头的16位标识（id）都是相同的
		3.每个小包的IP协议头的三位标识字段中，第二位置为0，表示允许分片，第三位是结束标识（当前是否是最后一个小包，是的话
		  置为 1，否则置为 0）
		4.到达对端时再将这些小包按顺序重组（13位片偏移），拼装到一起返回给运输层
		5.一旦这些小包中任意一个小包丢失，接收端重组就会失败，但是IP层不会负责重新传输数据	
	    MTU对UDP协议的影响
		1.一旦UDP携带的数据超过1472（1500-20(IP首部)-8(UDP首部)）字节，那么在网络层就会分成多个IP数据报
		2.多个IP数据报任意一个丢失，都会引起接收端网络层重组失败，那么这意味着，如果UDP数据报在网络层被分片，整个数据报丢
		  失的概率就大大增加了
	    MTU对TCP协议的影响
		1.TCP的一个数据报也不能无限大，还是受制于链路层的MTU TCP的单个数据的最大消息长度称为MSS
		2.TCP在建立连接的过程中，通信双方会进行MSS协商
		3.最理想的情况下，MSS的值正好是IP数据报不会被分片处理的最大长度
		4.双方在发送SYN的时候会在TCP头部写入自己能支持的MSS值
		5.然后双方得知对方的MSS值之后，选择较小的作为最终的MSS
		6.MSS值就是在TCP首部的40字节变长选项中
	6.ARP协议  介于数据链路层和网络层之间的数据
	    1.ARP协议的作用
	      ARP协议建立了主机IP地址和MAC地址的映射关系
		1.在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址
		2.数据包首先是被网卡接收到再去交付上层协议的，如果接收到的数据包的硬件地址和本地不符，则直接丢弃
		3.因此在通讯前必须获得目的主机的硬件地址
	    2.ARP协议格式
		1.注意到源MAC地址、目的MAC地址在以太网首部和ARP请求中各出现一次，对于链路层为以太网的情况是多余的，但如果链路层是
		  其他类型的网络则有可能是必要的
		2.2字节硬件类型指链路层网络类型，1为以太网
		3.2字节协议类型指的是要转换的地址类型，0x0800为IP地址
		4.硬件地址长度对于以太网地址为6字节
		5.协议地址长度对于IP地址为4字节
		6.op字段为1表示ARP请求，op字段为2表示ARP应答
	
		7.ARP请求/应答数据报长度28字节
	    3.ARP协议的工作流程
		1.源主机发送ARP请求，询问"目的IP地址是192.168.20.2的主机硬件地址是多少"，并将这个请求广播到本地网段（以太网帧首部
		  的目的硬件地址填FF:FF:FF:FF:FF:FF表示广播）
		2.目的主机接收到广播的ARP请求，发现其中的目的IP地址与本地的IP地址一样，则发送一个ARP应答数据报给源主机，将自己的硬
		  件地址填写在应答包中
		3.每台主机都维护一个ARP缓存表，可以用 arp -a 命令查看。缓存表中的表项一般有过期时间（一般为20分钟），如果20分钟内
		  没有再次使用某个表项，则该表项失效，下次使用时还要发ARP请求来获取目的主机的硬件地址	    
    五.物理层  负责光/电信号的传递方式 集线器 以太网协议
    附加：其他重要协议或技术
	1.DNS  是一套从域名映射到IP的系统
	    1.DNS背景
	      TCP/IP中使用IP地址和端口号来确定网络上的一台主机的一个程序，但是IP地址不方便记忆
	      于是人们发明了一种叫做主机名的东西，是一个字符串，并且使用hosts文件来描述主机名和IP地址的关系
              
	      最初，通过互联网信息中心（SRI-NIC）来管理这个hosts文件
	          1.如果一个新的计算机要接入网络，或者某个计算机的IP地址变更，都需要到信息中心申请变更hosts文件
		  2.其他计算机也要定期下载最新版本的hosts文件才能正确上网
	      这样太麻烦了，于是产生了DNS系统
	          1.一个组织的系统管理机构，维护系统内的每个主机的IP地址和主机名的对应关系
		  2.如果新计算机接入到网络，就将这个信息注册到数据库中
		  3.用户输入域名的时候，会自动查询DNS服务器，由DNS服务器检索数据库，得到对应的IP地址

	      至今，我们的计算机上仍然保留了hosts文件，在域名解析的过程中会优先查找hosts文件的内容
	          cat /etc/hosts
	2.域名简介
	  域名是用来识别主机名称和主机所属组织机构的一种分层结构名称
	  域名使用 . 连接
	  对于http://www.baidu.com
	      com：一级域名，com表示这是一个企业域名，同级的还有net（网络提供商）、org（非盈利组织）等
	      baidu.com：二级域名，公司名
	      www：只是一种习惯用法
	3.域名服务器
	  域名是分层结构，域名服务器也是对应的层次结构
	      每个层的域名上都有自己的域名服务器，最顶层的是根域名服务器，根域名服务器全世界很少，中国没有
	      每一级域名服务器都知道上级域名服务器的IP地址
	      为了容灾，每一级至少设置两个或以上的域名服务器

	  域名解析过程
 	      1.输入域名后，先查找自己主机对应的域名服务器
	      2.域名服务器先查找自己数据库中的数据，如果没有，请求上级域名服务器进行查找，依次类推
	      3.最多到根域名服务器，肯定能找到这个域名对应的IP地址，将查找到的IP地址返回给客户端
	      4.域名服务器自身也会进行一些缓存，把曾经访问过的域名和对应的IP地址缓存起来，可以加速查找过程

	  经典面试题：浏览器中输入url后，发生的事情
	      原文：http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/
	      翻译：https://blog.csdn.net/wuhenliushui/article/details/20038819/
	4.ICMP协议
	  ICMP是一个网络层协议
	  一个新搭建好的网络，往往需要先进行一个简单的测试，来验证网络是否畅通，但IP协议并不提供可靠传输，如果丢包了，IP协议并不能
	  通知传输层是否丢包以及丢包的原因
	    1.ICMP功能
	    	确认IP包是否成功到达目标地址
		通知在传输过程中IP包被丢弃的原因
		ICMP也是基于IP协议工作的，但他并不是传输层的功能，因此人们仍然把他归结为网络层协议
		ICMP只能搭配IPV4使用，如果是IPV6的情况，需要时用ICMPv6
	    2.ICMP的报文格式
		1字节类型（了解）
		    0  回送应答
		    3  目标不可达
		    4  原点抑制
                    5  重定向或改变路由
		    8  回送请求
		    9  路由器公告
  		    10 路由器请求
		    11 超时
		    17 地址子网请求
		    18 地址子网应答
		1字节代码
		2字节校验和
		数据：不同的类型和代码有不同的内容
	    3.ICMP大概分为两类报文
		一类是通知出错原因
		一类是用于诊断查询
	5.ping命令   ping www.baidu.com
	    注意，此处ping的是域名，而不是url，一个域名可以通过DNS解析成IP地址
	    ping命令不光能验证网络的连通性，同时也会统计响应时间和TTL（生存周期）
	    ping命令会先发送一个ICMP Echo Request（回送请求）给对端
	    对端接收到之后，会返回一个ICMP Echo Reply（回送应答）给发送端

	    一个值得注意的坑！！！
	    telnet是23号端口，ssh是22号端口，那么ping是什么端口？
	    ping命令是基于ICMP实现的，ICMP是网络层协议，而端口号是传输层的内容，所以不会存在端口信息
	6.traceroute命令  "跟踪"
	  也是基于ICMP协议实现的，能够打印出可执行程序主机到目标主机之间经历多少路由器
	7.NAT技术
	    1.NAT技术背景
	      NAT技术是当前解决IP地址不够用的主要手段，是路由器的一个重要功能
	          1.对外通信时NAT能够将私有IP转为全局IP，也就是一种将私有IP和全局IP相互转化的技术
		  2.很多学校、家庭、公司内部采用每个终端设置的私有IP，而在路由器或必要的服务器上设置全局IP
		  3.全局IP要求唯一，但是私有IP不需要，在不同的局域网中出现相同的私有IP是完全不影响的
	    2.NAT IP转换过程
  	        1.NAT路由器将源地址 10.0.0.10 替换成全局IP 202.244.174.37
		2.NAT路由器收到外部的数据时，又会把目标IP从 202.244.174.37 替换回 10.0.0.10
		3.在NAT路由表内部，有一张自动生成的，用于地址转换的表
		4.当 10.0.0.10 第一次向 202.244.174.37 发送数据时就会生成表中的映射关系
	    
		那么问题来了，如果局域网内，同一台主机的多个应用程序同时访问同一个外网服务器，那么对于服务器返回的数据，目的IP都是
		相同的，这时候路由器如何判定将这个数据报转发给局域网的哪个主机？
		这个时候NAPT来解决这个问题了，使用IP+port来建立这个关联关系  这种关联关系也是NAT路由器自动维护的
	    3.NAT技术缺陷
	      由于NAT技术依赖这个转换表，所以有诸多限制
		1.无法从外部向内部服务器建立连接
		2.转换表的生成和销毁都需要额外开销
		3.通信过程中一旦NAT设备异常，即使存在热备，所有的TCP连接也都会断开
	    4.NAT和代理服务器
	      路由器往往都具备NAT设备的功能，通过NAT设备进行中转，完成子网设备和其他子网设备的通信过程
	      代理服务器看起来和NAT设备有点类似，客户端向代理服务器发起请求，代理服务器将请求转发给真正的服务器，服务器返回结果后
	      代理服务器又把结果回传给客户端

	      NAT和代理服务器的区别
	          1.从应用上将，NAT设备是网络基础设备之一，解决的是IP地址不够用的问题，代理服务器则是更贴近具体应用，比如通过代理
		    服务器进行翻墙，另外像迅游这样的加速器，也是使用代理服务器
		  2.从底层上讲，NAT工作在网络层，直接对IP地址进行替换，代理服务器往往工作在应用层
		  3.从使用范围上讲，NAT一般在局域网的出口部署，代理服务器可以在局域网做，也可以在广域网做，也可以跨网
		  4.从部署位置上看，NAT一般集成在防火墙、路由器等硬件设备上，代理服务器则是一个软件程序，需要部署在服务器上

		  代理服务器是一种应用比较广的技术
		  翻墙：广域网中的代理
		  负载均衡：局域网中的代理

数据的封装和分用

socket 编程接口：
	1.socket API是一套抽象的网络编程接口，适用于各种底层网络协议，如 IPV4、IPV6，然而，各种网络协议的地址格式并不相同
		1.IPV4 的地址用 sockaddr_in 结构体表示，包括 16 位地址类型、16 位端口号和 32 位IP地址
		2.IPV4、IPV6 地址类型分别定义为 AF_INET、AF_INET6
		3.socket API 都用 struct sockaddr* 结构表示地址协议，在使用的时候需要强制转换成具体的地址结构，这样的好处是程序的
	          通用性 
	2.同时 socket 也是一个数据结构
	3.对于网络编程来说，第一步永远是创建套接字，套接字创建成功后，通过对套接字的操作，来完成网络上数据的传输
       	int socket(int domain, int type, int protocol);


UDP 网络程序：
	UDP 服务端：
		1.socket 的参数使用 SOCK_DGRAM 表示UDP 数据包套接字
		2.bind 之后就可以直接进行通信了
       		int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
		
		3.使用 sendto 和 recvfrom 来进行数据读写
		//ssize_t recv(int sockfd, void *buf, size_t len, int flags);
       		ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                                 struct sockaddr *src_addr, socklen_t *addrlen);

		//ssize_t send(int sockfd, const void *buf, size_t len, int flags);
      	        ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
			       const struct sockaddr *dest_addr, socklen_t addrlen);
	UDP 客户端：
		客户端程序我们不推荐绑定地址信息，因为绑定有可能失败，客户端发送数据的时候，具体用哪个地址和端口我们都无所谓，
		只要数据发送成功就可以，发送数据的时候，操作系统检测到 socket 没有绑定地址信息，会自动选择合适的地址和端口号
		为 socket 绑定，这样一般不会出错

地址转换函数：
	1.字符串转 in_addr 的函数：
	in_addr_t inet_addr(const char *cp);
	int inet_aton(const char *cp, struct in_addr *inp);	
	int inet_pton(int af, const char *src, void *dst);  //可以转换 IPV6 的 in6_addr

	2.in_addr 转字符串的函数：
	char *inet_ntoa(struct in_addr in);
		1.函数返回了一个 char*，很显然这个函数在内部为我们申请了一块内存来保存转换后的结果
		2.把这个返回结果放到了静态存储区，我们不需要手动释放
		3.不是线程安全函数
		4.在多线程环境下，使用 inet_ntop，这个函数由调用者提供一个缓冲区保存结果，可以规避线程安全问题
	const char *inet_ntop(int af, const void *src,char *dst, socklen_t size);  //可以转换 IPV6 的 in6_addr

TCP 网络程序：
	TCP 服务器：
		1.int socket(int domain, int type, int protocol);
		    1.打开一个网络通讯端口，如果成功的话，就像 open 一样返回一个文件描述符
		    2.应用程序可以像读写文件一样用 read/send 收发数据
		    3.调用出错，返回 -1
		    4.对于 TCP 协议，参数指定为 SOCK_STREAM，表示面向流的传输协议
		2.int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
		    1.服务器程序所监听的地址和端口通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接
		      服务器程序需要调用 bind 绑定一个固定的网络地址和端口号
		    2.成功返回 0，失败返回 -1
		    3.bind 的作用是将 sockfd 与 addr 绑定在一起，使 sockfd 这个用于网络通信的描述符监听 addr 所描述的地址和端口号
		    4.struct sockaddr 是一个通用的结构体，addr 参数可以接受多种协议的 sockaddr 结构体，而它们的大小各不相同，所以
		      需要第三个参数来指定结构体长度

		    5.addr 参数的初始化：
		        server.family = AF_INET;
			server.sin_port = htons(...);
			server.sin_addr.s_addr = htonl(INADDR_ANY);
			INADDR_ANY 这个宏表示本地的任意 IP 地址，因为服务器可能有多个网卡，每个网卡也可能绑定了多个 IP 地址，这样
			设置可以在所有的 IP 地址上监听，直到与某个客户端建立了连接时才确定下来到底用哪个 IP 地址
		3.int listen(int sockfd, int backlog);
		    1.listen 申明 sockfd 处于监听状态，并且最多允许有 backlog 个客户端处于连接等待状态，如果接收到更多的连接请求
		      就忽略，这里设置一般不会太大（一般是 5）  挂起连接队列可能增长到的最大长度
		    2.成功返回 0，失败返回 -1
		4.int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
		    1.三次握手完成后，服务器调用 accept 接受连接
		    2.如果服务器调用 accept 时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来
		    3.这里 addr 是一个传出参数，accept 返回时传出客户端的地址和端口号
		    4.如果 addr 指定为 NULL，表示不关心客户端的地址
		    5.addrlen 是一个传入传出参数
	TCP 客户端：
		1.由于客户端不需要固定的端口号，因此不必调用 bind,客户端的端口号由内核自动分配
		2.客户端不是不允许调用 bind,只是没有必要调用 bind 固定一个端口号，否则如果在同一台机器上启动多个客户端，就会出现
		  端口号被占用导致不能正确建立连接
		3.int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
		    1.客户端调用 connect 连接服务器
		    2.connect 的地址信息是对方的
		    3.成功返回 0，失败返回 -1
