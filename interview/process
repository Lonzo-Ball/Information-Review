问题：什么情况下会造成死锁，死锁的四个必要条件？ ##
    死锁的四个必要条件：
	1.互斥条件：进程对所分配到的资源进行排他性使用，即在一段时间内，某资源只能被一个进程占用。如果此时还有其它进程请求该资源，则请求进程只能等待，
	  直到占用该资源的进程用完释放
	2.请求保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占用，此时请求进程被阻塞，但又对自己已获得的资源保持不变
	3.不可抢占条件：进程已获得的资源在未使用完之前不能被抢占，只能在进程使用完时由自己释放
	4.循环等待条件：在发生死锁时，毕竟存在一个由进程构成的资源循环链（进程集合{p1,p2,...,pn}中的p0正在等待一个p1占用的资源，p1正在等待p2占用的资源，
	  ...，pn正在等待p0占用的资源）

问题：怎么保证线程的同步和互斥？ ##
    信号量机制

问题：进程间通信的方式有哪些？ ##
    进程间通信的目的（掌握）：
	1.数据传输：一个进程需要将它的数据发送给另一个进程
	2.资源共享：多个进程之间共享同样的资源
	3.通知事件：一个进程需要向另一个/一组进程发送消息，通知它/它们发生了某种事件（如子进程退出时要通知父进程）
	4.进程控制：有些进程希望完全控制另一个进程的执行，此时控制进程希望能够拦截另一个进程陷入的所有异常，并能够及时知道它的状态改变
    进程间通信的发展（了解）：
	管道
	    1.匿名管道
	    2.命名管道
	System V 进程间通信
	    1.消息队列
	    2.共享内存
	    3.信号量
	POSIX 进程间通信
	    1.消息队列
	    2.共享内存
	    3.信号量
	    4.互斥量
	    5.条件变量
	    6.读写锁
    进程间通信的方式（熟悉）：
	1.管道：Unix 中最古老的进程间通信方式
	  匿名管道
	      管道的读写规则：
		  1.当没有数据可读时：
		      O_NONBLOCK disable：read调用阻塞，即进程暂停执行，一直等到有数据来为止
		      O_NONBLOCK enable：read调用返回-1，errno值为EAGAIN
		  2.当管道满的时候：
		      O_NONBLOCK disable： write调用阻塞，直到有进程读走数据
		      O_NONBLOCK enable：write调用返回-1，errno值为EAGAIN
		  3.如果所有管道写端对应的文件描述符被关闭，则read返回0
                  4.如果所有管道读端对应的文件描述符被关闭，则write操作会产生信号SIGPIPE,进而可能导致write进程退出
		  5.当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。
		  6.当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性
	      管道特点：
		  1.只能用于具有共同祖先的进程（具有亲缘关系的进程）之间进行通信；通常，一个管道由一个进程创建，然后该进程调用fork，此后父子进程之间就
		    可应应用该管道。
		  2.管道提供流式服务
		  3.一般而言，进程退出，管道释放，所以管道的生命周期随进程
		  4.一般而言，内核会对管道操作进行同步与互斥
		  5.管道是半双共的，数据只能向一个方向流动，需要双方通信时，需要建立起两个管道
	  命名管道：一种特殊类型的文件
	      命名管道的打开规则：
		  1.如果当前打开操作是为读而打开 FIFO 时
		      O_NONBLOCK disable：阻塞至到有相应进程为写而打开该 FIFO
		      O_NONBLOCK enable：立即返回成功
		  2.如果当前打开操作是为写而打开 FIFO 时
		      O_NONBLOCK disable：阻塞至到有相应进程为读而打开该 FIFO
                      O_NONBLOCK enable：立即返回失败，错误码为 ENXIO
	      匿名管道与命名管道的区别：
		  1.匿名管道由pipe函数创建并打开
		  2.命名管道由mkfifo函数创建，打开用open
		  3.FIFO（命名管道）与pipe（匿名管道）之间唯一的区别在它们创建与打开的方式不同，一旦这些工作完成之后，它们具有相同的语义

	内核为每个 IPC 对象维护一个数据结构
	struct ipc_perm {
	__kernel_key_t	key;
	__kernel_uid_t	uid;
	__kernel_gid_t	gid;
	__kernel_uid_t	cuid;
	__kernel_gid_t	cgid;
	__kernel_mode_t	mode; 
	unsigned short	seq;
	};
	2.消息队列
	      1.消息队列提供了一个从一个进程向另外一个进程发送一块数据的方法
              2.每个数据块都被认为是有一个类型，接收者进程接收的数据块可以有不同的类型值
              3.消息队列也有管道一样的不足，就是每个消息的最大长度是有上限的（MSGMAX），每个消息队列的总的字节数是有上限的（MSGMNB），系统上消息队列的
		总数也有一个上限（MSGMNI）
	3.共享内存
	      1.共享内存是最快的IPC形式。一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递不再涉及到内核，换句话说是进程不再通过执行进入内核
	        的系统调用来传递彼此的数据
	      2.共享内存没有进行同步与互斥
	4.信号量
	      1.信号量主要用于同步和互斥
	      2.进程间的同步指的是多个进程需要相互配合共同完成一项任务
	      3.由于各进程需要共享资源，有些资源需要互斥使用，因此各进程间竞争使用这些资源，进程的这种关系为进程间的互斥
              4.系统中某些资源一次只允许一个进程使用，称这样的资源为临界资源或互斥资源。
	      5.在进程中涉及到互斥资源的程序段叫临界区

	      6.信号量和 P、V 原语：
		  信号量：
		      1.互斥：P、V在同一个进程中
                      2.同步：P、V在不同进程中
		  信号量值含义：
		      1.S > 0 ：S表示可用资源的个数
		      2.S = 0 ：表示无可用资源，无等待进程
		      3.S < 0 : |S| 表示等待队列中进程个数
	      7.信号量结构体伪代码：
	        信号量本质上是一个计数器
	        struct semaphore {
 	       	       int value;
	               pointer_PCB queue;
	        }
	      8.P 原语
		P(s)
		{
 			s.value = s.value--;
 			if (s.value < 0)
 			{
				该进程状态置为等待状态
				将该进程的PCB插入相应的等待队列s.queue末尾
 			}
		}		
	      9.V 原语
		V(s)
		{
 			s.value = s.value++;
 			if (s.value < =0)
 			{
				唤醒相应等待队列s.queue中等待的一个进程
				改变其状态为就绪态
				并将其插入就绪队列
 			}
		}
  进程间通信总结（掌握）：
      IPC 资源必须删除，否则不会自动清除，除非重启，所以 system V IPC 资源的生命周期随内核
