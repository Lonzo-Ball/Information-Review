问题：vector 中存类对象，这个类需要有什么函数？ ##
    首先 vector 中 push_back 对象之前，你得有对象，所以这个类中构造函数是肯定会用到的
    然后呢，对象最终是会调用析构函数的，所以这个类中析构函数是肯定会用到的

    在不断 push_back 的过程中还会用到拷贝构造函数：
	1.当 push_back 第一个对象 t1 时，先调用拷贝构造函数用 t1 构造出一个新的对象，将拷贝出来的新对象插入到 vector 当中，此时 capacity = 1
        2.当 push_back 第二个对象 t2 时，需要增容，先调用拷贝构造函数用 vector 中第一个元素构造出一个新对象，将拷贝出来的新对象插入到 vector 的新空间当中
          再调用拷贝构造函数用 t2 构造出一个新对象，将拷贝出来的新对象插入到 vector 当中，此时 capacity = 2,再调用析构函数完成清理任务，接着释放旧空间
	3.依次类推

问题：C++ 中友元破坏了封装性，为什么还要用它？ ##
    友元分为：友元函数和友元类
    友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，不宜多用

    友元函数：
	问题：现在我们尝试去重载operator<<，然后发现我们没办法将operator<<重载成成员函数
	因为cout的输出流对象和隐含的this指针在抢占第一个参数的位置。this指针默认是第一个参数也就是左操作数了。但是实际使用中cout需要是第一个形参对象，
	才能正常使用。所以我们要将operator<<重载成全局函数。但是这样的话，又会导致类外没办法访问成员，那么这里就需要友元来解决
	friend istream& operator>>(istream &_cin,Date &d);
        friend ostream& operator<<(ostream &_cout,Date &d);

	友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声明，声明时需要加friend关键字
	友元函数可访问类的私有成员，但不是类的成员函数
	友元函数不能用const修饰
	友元函数可以在类定义的任何地方声明，不受类访问限定符限制
	一个函数可以是多个类的友元函数
	友元函数的调用与普通函数的调用和原理相同

    友元类：
	友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员
	友元关系是单向的，不具有交换性
	友元关系不能传递

问题：strcpy 函数的模拟实现？ ##
    1.函数原型：
      char* strcpy(char * destination, const char * source );
    2.关于该函数：
	1.源字符串必须以 '\0' 结束
	2.会将源字符串的 '\0' 拷贝到目标空间
	3.目标空间必须足够大，以确保能存放源字符串
	4.目标空间必须可变

	5.返回char*使函数能够支持链式表达式
    3.模拟实现：
      	char* my_strcpy(char* dest,const char* src){
         	assert(NULL != dest && NULL != src);
 
         	char* cur = dest;
         	while ((*cur++ = *src++) != '\0') {
                 	;
         	}
 
         	return dest;
	}

    4.内存重叠问题：
      条件：dest >= src && dest <= (src+strlen(src)-1)
    5.内存操作函数： 	
	1.memcpy
	    1.函数原型：
		void * memcpy ( void * destination, const void * source, size_t num ); 
	    2.关于该函数：
		1.函数 memcpy 从 source 的位置开始向后复制 num 个字节的数据到 destination 指向的内存空间当中
		2.这个函数在遇到 '\0' 时并不会停下来
		3.如果 destination 和 source 有任何的内存重叠，复制的结果都是未定义的
	2.memmove
	    1.函数原型：
		void * memmove ( void * destination, const void * source, size_t num );
	    2.关于该函数：
		1.memmove 处理的内存块是可以重叠的
		2.如果源内存块和目标内存块出现重叠，就得使用 memmove 函数处理
	    3.模拟实现：
	      	void * my_memmove ( void * dest, const void * src, size_t num ){
	        	assert(NULL != dest && NULL != src);
 
        	 	char *cur = (char*)dest;
        	 	char *src_ = (char*)src;
               	 	if (cur >= src_ && cur <= (src_+num-1)) {
				cur = cur+num-1;
                 		src_ = src_+num-1;
                 		while(num--){
                        	 	*cur-- = *src_--;
                 		}
         		}
         		else{	
				while(num--){
					*cur++ = *src_++;
         	        	}
                	}
	      	}

问题：对函数调用的理解？ ##
    1.寄存器：
   	1.esp：栈顶寄存器，存放栈顶指针
	2.ebp：栈底寄存器，存放栈底指针
	3.eip(pc)：程序计数器
	
	4.eax：通用寄存器
	5.ecx：通用寄存器

    2.函数栈帧的概念：
	1.其实main函数是在 __tmainCRTStartup 函数中调用的，而 __tmainCRTStartup 函数是在 mainCRTStartup 被调用的
	2.每一个函数调用都是一个过程，这个过程我们通常称之为函数的调用过程。这个过程要为函数开辟栈空间，用于本次函数调用中临时变量的保存、现场保护。这个
          栈空间我们称之为函数栈帧

    3.函数调用过程中一些重要指令：
	1.call指令的调用：
	    1.先要压栈call指令下一条指令的地址
	    2.然后跳转到被调用函数的地方(jmp)
	2.pop ebp指令：出栈，将出栈的内容保存到ebp，将ebp置回为调用函数的栈底
	3.ret指令：
	    1.会导致当前栈顶元素出栈
	    2.并将出栈的内容当作地址，将程序执行流跳转到该地址处

    4.研究函数调用过程实现实验中得出的一些结论：
	1.中间变量存在于调用函数栈帧与被调用函数栈帧之间
	2.函数形参入栈的顺序是从右到左
	3.临时变量存在于当前函数自己的栈帧中，随着栈帧的销毁而销毁
	4.函数的栈帧是由自己开辟的
	5.返回值是通过寄存器带回的
	6.eip寄存器（俗称pc指针）存放的是当前指令的下一条指令地址
	7.函数的调用是通过call指令实现跳转，ret指令返回的
	8.观察栈帧结构发现，call指令的下一条指令的地址位于（被调用函数第一个自定义变量地址+2）处，所以只要我们自己定义一个变量，就很容易找到call指令的下
	  一条指令的地址，然后对该指针进行修改，跳转到你所指定的地方

问题：C语言实现封装/继承/多态了解过吗？ ##
    1.基本知识：
        1.结构体
	2.函数指针
	3.extern与static
	  extern : 可用于修饰函数或者变量，表示该变量或者函数在其他文件中进行了定义
	  static : 可用于修饰函数或者变量，表示该函数或者变量只能在该文件中使用
	  可以利用它们对数据或者函数进行隐藏或者限制访问范围
    2.封装：封装的本质是为了更好地管理
	在C语言中，可以用结构+函数指针来模拟类的实现，而用这种结构定义的变量就是对象
	有两种方法实现封装：
	    1.在头文件中声明，在C文件中真正定义它
	    2.把私有数据信息放在一个不透明的priv变量或者结构体中。只有类的实现代码才知道priv或者结构体的真正定义
    3.继承
	在C语言中，可以利用“结构在内存中的布局与结构的声明具有一致的顺序”这一事实实现继承
    4.多态
	可以使用C语言中的万能指针 void* 实现多态
